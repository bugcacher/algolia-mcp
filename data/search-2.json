"/1/clusters/mapping/batch": {
      "post": {
        "tags": ["search"],
        "operationId": "batchAssignUserIds",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "Assign multiple userIDs",
        "description": "Assigns multiple user IDs to a cluster.\n\n**You can't move users with this operation**.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/UserIDInHeader"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "title": "batchAssignUserIdsParams",
                "type": "object",
                "description": "Assign userID parameters.",
                "additionalProperties": false,
                "properties": {
                  "cluster": {
                    "$ref": "#/components/schemas/clusterName"
                  },
                  "users": {
                    "type": "array",
                    "description": "User IDs to assign.",
                    "example": ["einstein", "bohr", "feynman"],
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": ["cluster", "users"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreatedAt"
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/clusters/mapping/top": {
      "get": {
        "tags": ["search"],
        "operationId": "getTopUserIds",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "Get top user IDs",
        "description": "Get the IDs of the 10 users with the highest number of records per cluster.\n\nSince it can take a few seconds to get the data from the different clusters,\nthe response isn't real-time.\n",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "getTopUserIdsResponse",
                  "type": "object",
                  "description": "User IDs and clusters.",
                  "properties": {
                    "topUsers": {
                      "type": "array",
                      "description": "Key-value pairs with cluster names as keys and lists of users with the highest number of records per cluster as values.",
                      "items": {
                        "type": "object",
                        "additionalProperties": {
                          "x-additionalPropertiesName": "cluster",
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/userId"
                          }
                        }
                      }
                    }
                  },
                  "required": ["topUsers"]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/clusters/mapping/{userID}": {
      "get": {
        "tags": ["search"],
        "operationId": "getUserId",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "Retrieve user ID",
        "description": "Returns the user ID data stored in the mapping.\n\nSince it can take a few seconds to get the data from the different clusters,\nthe response isn't real-time.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/UserIDInPath"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/userId"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      },
      "delete": {
        "tags": ["search"],
        "operationId": "removeUserId",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "Delete user ID",
        "description": "Deletes a user ID and its associated data from the clusters.",
        "parameters": [
          {
            "$ref": "#/components/parameters/UserIDInPath"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "removeUserIdResponse",
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "deletedAt": {
                      "$ref": "#/components/schemas/deletedAt"
                    }
                  },
                  "required": ["deletedAt"]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/clusters": {
      "get": {
        "tags": ["search"],
        "operationId": "listClusters",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "List clusters",
        "description": "Lists the available clusters in a multi-cluster setup.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "listClustersResponse",
                  "type": "object",
                  "description": "Clusters.",
                  "properties": {
                    "topUsers": {
                      "type": "array",
                      "description": "Key-value pairs with cluster names as keys and lists of users with the highest number of records per cluster as values.",
                      "items": {
                        "$ref": "#/components/schemas/clusterName"
                      }
                    }
                  },
                  "required": ["topUsers"]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/clusters/mapping/search": {
      "post": {
        "tags": ["search"],
        "operationId": "searchUserIds",
        "deprecated": true,
        "x-use-read-transporter": true,
        "x-cacheable": true,
        "x-acl": ["admin"],
        "summary": "Search for user IDs",
        "description": "Since it can take a few seconds to get the data from the different clusters,\nthe response isn't real-time.\n\nTo ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "title": "searchUserIdsParams",
                "type": "object",
                "description": "OK",
                "additionalProperties": false,
                "properties": {
                  "query": {
                    "type": "string",
                    "description": "Query to search. The search is a prefix search with [typo tolerance](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/) enabled. An empty query will retrieve all users."
                  },
                  "clusterName": {
                    "$ref": "#/components/schemas/clusterName"
                  },
                  "page": {
                    "$ref": "#/components/schemas/page"
                  },
                  "hitsPerPage": {
                    "$ref": "#/components/schemas/hitsPerPage"
                  }
                },
                "required": ["query"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "searchUserIdsResponse",
                  "type": "object",
                  "description": "userIDs data.",
                  "properties": {
                    "hits": {
                      "type": "array",
                      "description": "User objects that match the query.",
                      "items": {
                        "title": "userHit",
                        "type": "object",
                        "properties": {
                          "userID": {
                            "$ref": "#/components/schemas/userID"
                          },
                          "clusterName": {
                            "$ref": "#/components/schemas/clusterName"
                          },
                          "nbRecords": {
                            "$ref": "#/components/schemas/nbRecords"
                          },
                          "dataSize": {
                            "$ref": "#/components/schemas/dataSize"
                          },
                          "objectID": {
                            "type": "string",
                            "description": "userID of the requested user. Same as userID."
                          },
                          "_highlightResult": {
                            "title": "userHighlightResult",
                            "type": "object",
                            "properties": {
                              "userID": {
                                "$ref": "#/components/schemas/highlightResult"
                              },
                              "clusterName": {
                                "$ref": "#/components/schemas/highlightResult"
                              }
                            },
                            "required": ["userID", "clusterName"]
                          }
                        },
                        "required": [
                          "userID",
                          "clusterName",
                          "nbRecords",
                          "dataSize",
                          "objectID",
                          "_highlightResult"
                        ]
                      }
                    },
                    "nbHits": {
                      "$ref": "#/components/schemas/nbHits"
                    },
                    "page": {
                      "$ref": "#/components/schemas/page"
                    },
                    "hitsPerPage": {
                      "$ref": "#/components/schemas/parameters_hitsPerPage"
                    },
                    "updatedAt": {
                      "$ref": "#/components/schemas/updatedAt"
                    }
                  },
                  "required": ["hits", "nbHits", "page", "hitsPerPage", "updatedAt"]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/clusters/mapping/pending": {
      "get": {
        "tags": ["search"],
        "operationId": "hasPendingMappings",
        "deprecated": true,
        "x-acl": ["admin"],
        "summary": "Get migration and user mapping status",
        "description": "To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.\n",
        "parameters": [
          {
            "in": "query",
            "name": "getClusters",
            "description": "Whether to include the cluster's pending mapping state in the response.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "hasPendingMappingsResponse",
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "pending": {
                      "description": "Whether there are clusters undergoing migration, creation, or deletion.",
                      "type": "boolean"
                    },
                    "clusters": {
                      "description": "Cluster pending mapping state: migrating, creating, deleting.\n",
                      "type": "object",
                      "additionalProperties": {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "required": ["pending"]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/security/sources": {
      "get": {
        "tags": ["search"],
        "operationId": "getSources",
        "x-acl": ["admin"],
        "summary": "List allowed sources",
        "description": "Retrieves all allowed IP addresses with access to your application.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/sources"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      },
      "put": {
        "tags": ["search"],
        "operationId": "replaceSources",
        "x-acl": ["admin"],
        "summary": "Replace allowed sources",
        "description": "Replaces the list of allowed sources.",
        "requestBody": {
          "required": true,
          "description": "Allowed sources.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/sources"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "replaceSourceResponse",
                  "type": "object",
                  "additionalProperties": false,
                  "required": ["updatedAt"],
                  "properties": {
                    "updatedAt": {
                      "$ref": "#/components/schemas/updatedAt"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/security/sources/append": {
      "post": {
        "tags": ["search"],
        "operationId": "appendSource",
        "x-acl": ["admin"],
        "description": "Adds a source to the list of allowed sources.",
        "summary": "Add a source",
        "requestBody": {
          "required": true,
          "description": "Source to add.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/source"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/CreatedAt"
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/security/sources/{source}": {
      "delete": {
        "tags": ["search"],
        "operationId": "deleteSource",
        "x-acl": ["admin"],
        "description": "Deletes a source from the list of allowed sources.",
        "summary": "Delete a source",
        "parameters": [
          {
            "name": "source",
            "in": "path",
            "required": true,
            "description": "IP address range of the source.",
            "schema": {
              "type": "string",
              "example": "10.0.0.1/32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "deleteSourceResponse",
                  "type": "object",
                  "additionalProperties": false,
                  "required": ["deletedAt"],
                  "properties": {
                    "deletedAt": {
                      "$ref": "#/components/schemas/deletedAt"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/logs": {
      "get": {
        "tags": ["search"],
        "operationId": "getLogs",
        "x-acl": ["logs"],
        "description": "The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).\n\n- Logs are held for the last seven days.\n- Up to 1,000 API requests per server are logged.\n- This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.\n",
        "summary": "Retrieve log entries",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "description": "First log entry to retrieve. The most recent entries are listed first.",
            "schema": {
              "type": "integer",
              "default": 0
            }
          },
          {
            "name": "length",
            "in": "query",
            "description": "Maximum number of entries to retrieve.",
            "schema": {
              "type": "integer",
              "default": 10,
              "maximum": 1000
            }
          },
          {
            "name": "indexName",
            "in": "query",
            "description": "Index for which to retrieve log entries.\nBy default, log entries are retrieved for all indices.\n",
            "example": "products",
            "schema": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "Type of log entries to retrieve.\nBy default, all log entries are retrieved.\n",
            "schema": {
              "$ref": "#/components/schemas/logType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "title": "getLogsResponse",
                  "type": "object",
                  "additionalProperties": false,
                  "required": ["logs"],
                  "properties": {
                    "logs": {
                      "type": "array",
                      "items": {
                        "title": "log",
                        "type": "object",
                        "properties": {
                          "timestamp": {
                            "type": "string",
                            "description": "Date and time of the API request, in RFC 3339 format.",
                            "example": "2023-03-08T12:34:56Z"
                          },
                          "method": {
                            "type": "string",
                            "description": "HTTP method of the request.",
                            "example": "GET"
                          },
                          "answer_code": {
                            "type": "string",
                            "description": "HTTP status code of the response.",
                            "example": "200"
                          },
                          "query_body": {
                            "type": "string",
                            "maxLength": 1000,
                            "description": "Request body.",
                            "example": "{\\n \\\"requests\\\": [\\n  {\\n   \\\"indexName\\\": \\\"best_buy\\\",\\n   \\\"params\\\": \\\"query=&hitsPerPage=10&page=0&attributesToRetrieve=*&highlightPreTag=%3Cais-highlight-0000000000%3E&highlightPostTag=%3C%2Fais-highlight-0000000000%3E&getRankingInfo=1&facets=%5B%22brand%22%2C%22categories%22%2C%22free_shipping%22%2C%22type%22%5D&tagFilters=\\\"\\n }\\n ]\\n}\\n"
                          },
                          "answer": {
                            "type": "string",
                            "maxLength": 1000,
                            "description": "Response body.",
                            "example": "'n{\\n \"results\": [\\n  {\\n   \"hits\": [\\n    {\\n \"name\": \"Amazon - Fire TV Stick\",\\n \"description\": \"Amazon Fire TV Stick connects to your TV's HDMI port. Just grab and go to enjoy Netflix, Prime Instant Video, Hulu Plus, YouTube.com, music, and much more.\",\\n     \"brand\": \"Amazon\",\\n     \"categories\": [\\n      \"TV & Home Theater\",\\n      \"Streaming Media Players\"\\n ],\\n     \"hierarchicalCategories\": {\\n      \"lvl0\": \"TV & Home Theater\",\\n      \"lvl1\": \"TV & Home Theater > Streaming Media Players\"\\n     },\\n \"type\": \"Streaming media player\",\\n     \"price\": 39.99,\\n     \"price_range\": \"1 }\\n   ]\\n  }\\n ]\\n}'\n"
                          },
                          "url": {
                            "type": "string",
                            "format": "uri-reference",
                            "description": "URL of the API endpoint.",
                            "example": "/1/indexes"
                          },
                          "ip": {
                            "type": "string",
                            "format": "ipv4",
                            "description": "IP address of the client that performed the request.",
                            "example": "93.184.216.34"
                          },
                          "query_headers": {
                            "type": "string",
                            "description": "Request headers (API keys are obfuscated).",
                            "example": "User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8x zlib/1.2.5\\nHost: example.com\\nAccept: */*\\nContent-Type: application/json; charset=utf-8\\nX-Algolia-API-Key: 20f***************************\\nX-Algolia-Application-Id: MyApplicationID\\n"
                          },
                          "sha1": {
                            "type": "string",
                            "description": "SHA1 signature of the log entry.",
                            "example": "26c53bd7e38ca71f4741b71994cd94a600b7ac68"
                          },
                          "nb_api_calls": {
                            "type": "string",
                            "description": "Number of API requests.",
                            "example": "1"
                          },
                          "processing_time_ms": {
                            "type": "string",
                            "description": "Processing time for the query in milliseconds.\nThis doesn't include latency due to the network.\n",
                            "example": "2"
                          },
                          "index": {
                            "type": "string",
                            "description": "Index targeted by the query.",
                            "example": "products"
                          },
                          "query_params": {
                            "type": "string",
                            "description": "Query parameters sent with the request.",
                            "example": "query=georgia&attributesToRetrieve=name,city,country"
                          },
                          "query_nb_hits": {
                            "type": "string",
                            "description": "Number of search results (hits) returned for the query.",
                            "example": "1"
                          },
                          "inner_queries": {
                            "type": "array",
                            "description": "Queries performed for the given request.",
                            "items": {
                              "title": "logQuery",
                              "type": "object",
                              "properties": {
                                "index_name": {
                                  "type": "string",
                                  "description": "Index targeted by the query.",
                                  "example": "products"
                                },
                                "user_token": {
                                  "type": "string",
                                  "description": "A user identifier.",
                                  "example": "93.189.166.128"
                                },
                                "query_id": {
                                  "type": "string",
                                  "description": "Unique query identifier.",
                                  "example": "96f59a3145dd9bd8963dc223950507c8"
                                }
                              }
                            }
                          }
                        },
                        "required": [
                          "timestamp",
                          "method",
                          "answer_code",
                          "query_body",
                          "answer",
                          "url",
                          "ip",
                          "query_headers",
                          "sha1",
                          "processing_time_ms"
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/task/{taskID}": {
      "get": {
        "tags": ["search"],
        "operationId": "getAppTask",
        "x-acl": ["editSettings"],
        "description": "Checks the status of a given application task.\n",
        "summary": "Check application task status",
        "parameters": [
          {
            "name": "taskID",
            "in": "path",
            "description": "Unique task identifier.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "example": 1506303845001
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTaskResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          }
        }
      }
    },
    "/1/indexes/{indexName}/task/{taskID}": {
      "get": {
        "tags": ["search"],
        "operationId": "getTask",
        "x-acl": ["addObject"],
        "description": "Checks the status of a given task.\n\nIndexing tasks are asynchronous.\nWhen you add, update, or delete records or indices,\na task is created on a queue and completed depending on the load on the server.\n\nThe indexing tasks' responses include a task ID that you can use to check the status.\n",
        "summary": "Check task status",
        "parameters": [
          {
            "$ref": "#/components/parameters/IndexName"
          },
          {
            "name": "taskID",
            "in": "path",
            "description": "Unique task identifier.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64",
              "example": 1506303845001
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTaskResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/indexes/{indexName}/operation": {
      "post": {
        "tags": ["search"],
        "operationId": "operationIndex",
        "x-acl": ["addObject"],
        "summary": "Copy or move an index",
        "description": "Copies or moves (renames) an index within the same Algolia application.\n\n- Existing destination indices are overwritten, except for their analytics data.\n- If the destination index doesn't exist yet, it'll be created.\n- This operation is resource-intensive.\n\n**Copy**\n\n- Copying a source index that doesn't exist creates a new index with 0 records and default settings.\n- The API keys of the source index are merged with the existing keys in the destination index.\n- You can't copy the `enableReRanking`, `mode`, and `replicas` settings.\n- You can't copy to a destination index that already has replicas.\n- Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits).\n- Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)\n\n**Move**\n\n- Moving a source index that doesn't exist is ignored without returning an error.\n- When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.\n  To access the original analytics in the dashboard, create an index with the original name.\n- If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices.\n- Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).\n\nThis operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/IndexName"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "title": "operationIndexParams",
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "operation": {
                    "$ref": "#/components/schemas/operationType"
                  },
                  "destination": {
                    "$ref": "#/components/schemas/indexName"
                  },
                  "scope": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/scopeType"
                    },
                    "description": "**Only for copying.**\n\nIf you specify a scope, only the selected scopes are copied. Records and the other scopes are left unchanged.\nIf you omit the `scope` parameter, everything is copied: records, settings, synonyms, and rules.\n"
                  }
                },
                "required": ["operation", "destination"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/UpdatedAt"
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/1/indexes": {
      "get": {
        "tags": ["search"],
        "operationId": "listIndices",
        "x-acl": ["listIndexes"],
        "summary": "List indices",
        "description": "Lists all indices in the current Algolia application.\n\nThe request follows any index restrictions of the API key you use to make the request.\n",
        "parameters": [
          {
            "$ref": "#/components/parameters/Page"
          },
          {
            "$ref": "#/components/parameters/HitsPerPage"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/listIndicesResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequest"
          },
          "402": {
            "$ref": "#/components/responses/FeatureNotEnabled"
          },
          "403": {
            "$ref": "#/components/responses/MethodNotAllowed"
          },
          "404": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/waitForApiKey": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "waitForApiKey",
        "summary": "Wait for an API key operation",
        "description": "Waits for an API key to be added, updated, or deleted.",
        "parameters": [
          {
            "in": "query",
            "name": "key",
            "description": "API key to wait for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "operation",
            "description": "Whether the API key was created, updated, or deleted.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/apiKeyOperation"
            }
          },
          {
            "in": "query",
            "name": "apiKey",
            "description": "Used to compare fields of the `getApiKey` response on an `update` operation, to check if the `key` has been updated.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/apiKey"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/getApiKeyResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/waitForTask": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "waitForTask",
        "summary": "Wait for operation to complete",
        "description": "Wait for a task to complete to ensure synchronized index updates.\n\nAll Algolia write operations are asynchronous. When you make a request for a write operation, for example, to add or update records in your index, Algolia creates a task on a queue and returns a taskID. The task itself runs separately, depending on the server load.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The name of the index on which the operation was performed.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "taskID",
            "description": "The taskID returned by the operation.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTaskResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/waitForAppTask": {
      "get": {
        "x-helper": true,
        "operationId": "waitForAppTask",
        "summary": "Wait for application-level operation to complete",
        "description": "Wait for a application-level task to complete.",
        "parameters": [
          {
            "in": "query",
            "name": "taskID",
            "description": "The taskID returned by the operation.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTaskResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        },
        "tags": ["search"]
      }
    },
    "/browseObjects": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "browseObjects",
        "summary": "Get all records from an index",
        "description": "You can use the browse method to get records from an indexâ€”for example, to export your index as a backup. To export all records, use an empty query.\n\nUse browse instead of search when exporting records from your index, when ranking, or analytics, isn't important. The Analytics API doesn't collect data when using browse.\n\nDon't use this method for building a search UI. Use search instead.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The name of the index on which the operation was performed.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "browseParams",
            "description": "Browse parameters.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/browseParamsObject"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No content."
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/generateSecuredApiKey": {
      "get": {
        "x-helper": true,
        "x-asynchronous-helper": false,
        "tags": ["search"],
        "operationId": "generateSecuredApiKey",
        "summary": "Create secured API keys",
        "description": "Generates a secured API key without any requests to Algolia's servers.\n\nSecured API keys are API keys that you generate on your server without any API request to Algolia.\nSecured API keys help in environments where you can't easily update the client-side code, such as mobile apps,\nor when you need to restrict access to a part of your index for every user.\n\nWhen your users start searching, instead of using the Search API key, they request a short-lived secured API key from your server.\nOn your server, you use this method to create a secured API key, with any restrictions you'd like, such as filters, index access restrictions,\nor expiration times. The API key gets longer the more restrictions you add.\nYour users then use the secured API key to search with Algolia.\n\nYou can't create secured API keys from other secured API keys or from your Admin API key.\nThe generated API key can have the same restrictions as the parent API key, or be more restrictive.\n",
        "parameters": [
          {
            "in": "query",
            "name": "parentApiKey",
            "description": "API key from which the secured API key will inherit its restrictions.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "restrictions",
            "description": "Restrictions to add to the API key.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/securedApiKeyRestrictions"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/replaceAllObjects": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "replaceAllObjects",
        "summary": "Replace all records in an index",
        "description": "Replace all records from your index with a new set of records.\n\nThis method lets you replace all records in your index without downtime. It performs these operations:\n  1. Copy settings, synonyms, and rules from your original index to a temporary index.\n  2. Add your new records to the temporary index.\n  3. Replace your original index with the temporary index.\n\nUse the safe parameter to ensure that these (asynchronous) operations are performed in sequence.\nIf there's an error duing one of these steps, the temporary index won't be deleted.\nThis operation is rate-limited.\nThis method creates a temporary index: your record count is temporarily doubled. Algolia doesn't count the three days with the highest number of records towards your monthly usage.\nIf you're on a legacy plan (before July 2020), this method counts two operations towards your usage (in addition to the number of records): copySettings and moveIndex.\nThe API key you use for this operation must have access to the index YourIndex and the temporary index YourIndex_tmp.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The `indexName` to replace `objects` in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "objects",
            "description": "List of objects to replace the current objects with.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          {
            "in": "query",
            "name": "batchSize",
            "description": "The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1000
            }
          },
          {
            "in": "query",
            "name": "scopes",
            "description": "List of scopes to kepp in the index. Defaults to `settings`, `synonyms`, and `rules`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/scopeType"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/replaceAllObjectsResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/chunkedBatch": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "chunkedBatch",
        "summary": "Replace all records in an index",
        "description": "Helper: Chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `batch` requests.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The `indexName` to replace `objects` in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "objects",
            "description": "List of objects to replace the current objects with.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          {
            "in": "query",
            "name": "action",
            "description": "The `batch` `action` to perform on the given array of `objects`, defaults to `addObject`.",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/action"
            }
          },
          {
            "in": "query",
            "name": "waitForTasks",
            "description": "Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "batchSize",
            "description": "The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/batchResponse"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/saveObjects": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "saveObjects",
        "summary": "Saves the given array of objects in the given index",
        "description": "Helper: Saves the given array of objects in the given index. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The `indexName` to save `objects` into.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "objects",
            "description": "The objects to save in the index.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          {
            "in": "query",
            "name": "waitForTasks",
            "description": "Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "in": "query",
            "name": "batchSize",
            "description": "The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1000
            }
          },
          {
            "in": "query",
            "name": "requestOptions",
            "description": "The request options to pass to the `batch` method.",
            "required": false,
            "schema": {
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/batchResponse"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/deleteObjects": {
      "post": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "deleteObjects",
        "summary": "Deletes every records for the given objectIDs",
        "description": "Helper: Deletes every records for the given objectIDs. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objectIDs in it.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The `indexName` to delete `objectIDs` from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "objectIDs",
            "description": "The objectIDs to delete.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "in": "query",
            "name": "waitForTasks",
            "description": "Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "in": "query",
            "name": "batchSize",
            "description": "The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.",
            "required": false,
            "schema": {
              "type": "integer"
            }
          },
          {
            "in": "query",
            "name": "requestOptions",
            "description": "The request options to pass to the `batch` method.",
            "required": false,
            "schema": {
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/batchResponse"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/partialUpdateObjects": {
      "post": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "partialUpdateObjects",
        "summary": "Replaces object content of all the given objects according to their respective `objectID` field",
        "description": "Helper: Replaces object content of all the given objects according to their respective `objectID` field. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The `indexName` where to update `objects`.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "objects",
            "description": "The objects to update.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          {
            "in": "query",
            "name": "createIfNotExists",
            "description": "To be provided if non-existing objects are passed, otherwise, the call will fail.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "in": "query",
            "name": "waitForTasks",
            "description": "Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "in": "query",
            "name": "batchSize",
            "description": "The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1000
            }
          },
          {
            "in": "query",
            "name": "requestOptions",
            "description": "The request options to pass to the `batch` method.",
            "required": false,
            "schema": {
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/batchResponse"
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/IndexNotFound"
          }
        }
      }
    },
    "/indexExists": {
      "get": {
        "x-helper": true,
        "tags": ["search"],
        "operationId": "indexExists",
        "summary": "Check if an index exists or not",
        "description": "You can initialize an index with any name. The index is created on Algolia's servers when you add objects or set settings. To prevent accidentally creating new indices, or changing existing indices, you can use the exists method. The exists method returns a boolean that indicates whether an initialized index has been created.\n",
        "parameters": [
          {
            "in": "query",
            "name": "indexName",
            "description": "The name of the index to check.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Index exists.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                }
              }
            }
          }
        }
      }
    },
    "/setClientApiKey": {
      "get": {
        "x-helper": true,
        "x-asynchronous-helper": false,
        "tags": ["search"],
        "operationId": "setClientApiKey",
        "summary": "Switch the API key used to authenticate requests",
        "description": "Switch the API key used to authenticate requests.\n",
        "parameters": [
          {
            "in": "query",
            "name": "apiKey",
            "description": "API key to be used from now on.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "No content."
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "applicationId": {
        "type": "apiKey",
        "in": "header",
        "name": "x-algolia-application-id",
        "description": "Your Algolia application ID."
      },
      "apiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "x-algolia-api-key",
        "description": "Your Algolia API key with the necessary permissions to make the request.\nPermissions are controlled through access control lists (ACL) and access restrictions.\nThe required ACL to make a request is listed in each endpoint's reference.\n"
      }
    },
    "schemas": {
      "attributeToUpdate": {
        "x-keep-model": true,
        "deprecated": true,
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/builtInOperation"
          }
        ]
      },
      "ErrorBase": {
        "description": "Error.",
        "type": "object",
        "x-keep-model": true,
        "additionalProperties": true,
        "properties": {
          "message": {
            "type": "string",
            "example": "Invalid Application-Id or API-Key"
          }
        }
      },
      "paramsAsString": {
        "description": "Search parameters as a URL-encoded query string.",
        "example": "hitsPerPage=2&getRankingInfo=1",
        "type": "string",
        "default": ""
      },
      "searchParamsString": {
        "type": "object",
        "title": "Search parameters as query string.",
        "description": "Search parameters as query string.",
        "additionalProperties": false,
        "x-discriminator-fields": ["params"],
        "properties": {
          "params": {
            "$ref": "#/components/schemas/paramsAsString"
          }
        }
      },
      "query": {
        "type": "string",
        "description": "Search query.",
        "default": "",
        "x-categories": ["Search"]
      },
      "searchParamsQuery": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "query": {
            "$ref": "#/components/schemas/query"
          }
        }
      },
      "filters": {
        "type": "string",
        "description": "Filter expression to only include items that match the filter criteria in the response.\n\nYou can use these filter expressions:\n\n- **Numeric filters.** `<facet> <op> <number>`, where `<op>` is one of `<`, `<=`, `=`, `!=`, `>`, `>=`.\n- **Ranges.** `<facet>:<lower> TO <upper>` where `<lower>` and `<upper>` are the lower and upper limits of the range (inclusive).\n- **Facet filters.** `<facet>:<value>` where `<facet>` is a facet attribute (case-sensitive) and `<value>` a facet value.\n- **Tag filters.** `_tags:<value>` or just `<value>` (case-sensitive).\n- **Boolean filters.** `<facet>: true | false`.\n\nYou can combine filters with `AND`, `OR`, and `NOT` operators with the following restrictions:\n\n- You can only combine filters of the same type with `OR`.\n  **Not supported:** `facet:value OR num > 3`.\n- You can't use `NOT` with combinations of filters.\n  **Not supported:** `NOT(facet:value OR facet:value)`\n- You can't combine conjunctions (`AND`) with `OR`.\n  **Not supported:** `facet:value OR (facet:value AND facet:value)`\n\nUse quotes around your filters, if the facet attribute name or facet value has spaces, keywords (`OR`, `AND`, `NOT`), or quotes.\nIf a facet attribute is an array, the filter matches if it matches at least one element of the array.\n\nFor more information, see [Filters](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/).\n",
        "example": "(category:Book OR category:Ebook) AND _tags:published",
        "x-categories": ["Filtering"]
      },
      "facetFilters": {
        "description": "Filter the search by facet values, so that only records with the same facet values are retrieved.\n\n**Prefer using the `filters` parameter, which supports all filter types and combinations with boolean operators.**\n\n- `[filter1, filter2]` is interpreted as `filter1 AND filter2`.\n- `[[filter1, filter2], filter3]` is interpreted as `filter1 OR filter2 AND filter3`.\n- `facet:-value` is interpreted as `NOT facet:value`.\n\nWhile it's best to avoid attributes that start with a `-`, you can still filter them by escaping with a backslash:\n`facet:\\-value`.\n",
        "example": [["category:Book", "category:-Movie"], "author:John Doe"],
        "oneOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/facetFilters"
            }
          },
          {
            "type": "string"
          }
        ],
        "x-categories": ["Filtering"]
      },
      "optionalFilters": {
        "description": "Filters to promote or demote records in the search results.\n\nOptional filters work like facet filters, but they don't exclude records from the search results.\nRecords that match the optional filter rank before records that don't match.\nIf you're using a negative filter `facet:-value`, matching records rank after records that don't match.\n\n- Optional filters don't work on virtual replicas.\n- Optional filters are applied _after_ sort-by attributes.\n- Optional filters are applied _before_ custom ranking attributes (in the default [ranking](https://www.algolia.com/doc/guides/managing-results/relevance-overview/in-depth/ranking-criteria/)).\n- Optional filters don't work with numeric attributes.\n",
        "example": ["category:Book", "author:John Doe"],
        "oneOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/optionalFilters"
            }
          },
          {
            "type": "string"
          }
        ],
        "x-categories": ["Filtering"]
      },
      "numericFilters": {
        "description": "Filter by numeric facets.\n\n**Prefer using the `filters` parameter, which supports all filter types and combinations with boolean operators.**\n\nYou can use numeric comparison operators: `<`, `<=`, `=`, `!=`, `>`, `>=`.\nComparisons are precise up to 3 decimals.\nYou can also provide ranges: `facet:<lower> TO <upper>`. The range includes the lower and upper boundaries.\nThe same combination rules apply as for `facetFilters`.\n",
        "example": [["inStock = 1", "deliveryDate < 1441755506"], "price < 1000"],
        "oneOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/numericFilters"
            }
          },
          {
            "type": "string"
          }
        ],
        "x-categories": ["Filtering"]
      },
      "tagFilters": {
        "description": "Filter the search by values of the special `_tags` attribute.\n\n**Prefer using the `filters` parameter, which supports all filter types and combinations with boolean operators.**\n\nDifferent from regular facets, `_tags` can only be used for filtering (including or excluding records).\nYou won't get a facet count.\nThe same combination and escaping rules apply as for `facetFilters`.\n",
        "example": [["Book", "Movie"], "SciFi"],
        "oneOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/tagFilters"
            }
          },
          {
            "type": "string"
          }
        ],
        "x-categories": ["Filtering"]
      },
      "page": {
        "type": "integer",
        "description": "Page of search results to retrieve.",
        "default": 0,
        "minimum": 0,
        "x-categories": ["Pagination"]
      },
      "aroundLatLng": {
        "type": "string",
        "description": "Coordinates for the center of a circle, expressed as a comma-separated string of latitude and longitude.\n\nOnly records included within a circle around this central location are included in the results.\nThe radius of the circle is determined by the `aroundRadius` and `minimumAroundRadius` settings.\nThis parameter is ignored if you also specify `insidePolygon` or `insideBoundingBox`.\n",
        "example": "40.71,-74.01",
        "default": "",
        "x-categories": ["Geo-Search"]
      },
      "aroundLatLngViaIP": {
        "type": "boolean",
        "description": "Whether to obtain the coordinates from the request's IP address.",
        "default": false,
        "x-categories": ["Geo-Search"]
      },
      "aroundRadiusAll": {
        "title": "all",
        "type": "string",
        "description": "Return all records with a valid `_geoloc` attribute. Don't filter by distance.",
        "enum": ["all"]
      },
      "aroundRadius": {
        "description": "Maximum radius for a search around a central location.\n\nThis parameter works in combination with the `aroundLatLng` and `aroundLatLngViaIP` parameters.\nBy default, the search radius is determined automatically from the density of hits around the central location.\nThe search radius is small if there are many hits close to the central coordinates.\n",
        "oneOf": [
          {
            "type": "integer",
            "minimum": 1,
            "description": "Maximum search radius around a central location in meters."
          },
          {
            "$ref": "#/components/schemas/aroundRadiusAll"
          }
        ],
        "x-categories": ["Geo-Search"]
      },
      "aroundPrecisionFromValue": {
        "title": "range objects",
        "type": "array",
        "items": {
          "title": "range",
          "type": "object",
          "description": "Range object with lower and upper values in meters to define custom ranges.",
          "properties": {
            "from": {
              "type": "integer",
              "description": "Lower boundary of a range in meters. The Geo ranking criterion considers all records within the range to be equal.",
              "example": 20
            },
            "value": {
              "type": "integer",
              "description": "Upper boundary of a range in meters. The Geo ranking criterion considers all records within the range to be equal."
            }
          }
        }
      },
      "aroundPrecision": {
        "description": "Precision of a coordinate-based search in meters to group results with similar distances.\n\nThe Geo ranking criterion considers all matches within the same range of distances to be equal.\n",
        "oneOf": [
          {
            "type": "integer",
            "default": 10,
            "description": "Distance in meters to group results by similar distances.\n\nFor example, if you set `aroundPrecision` to 100, records wihin 100 meters to the central coordinate are considered to have the same distance,\nas are records between 100 and 199 meters.\n"
          },
          {
            "$ref": "#/components/schemas/aroundPrecisionFromValue"
          }
        ],
        "x-categories": ["Geo-Search"]
      },
      "insideBoundingBoxArray": {
        "type": "array",
        "items": {
          "type": "array",
          "minItems": 4,
          "maxItems": 4,
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "description": "Coordinates for a rectangular area in which to search.\n\nEach bounding box is defined by the two opposite points of its diagonal, and expressed as latitude and longitude pair:\n`[p1 lat, p1 long, p2 lat, p2 long]`.\nProvide multiple bounding boxes as nested arrays.\nFor more information, see [rectangular area](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas).\n",
        "example": [
          [47.3165, 4.9665, 47.3424, 5.0201],
          [40.9234, 2.1185, 38.643, 1.9916]
        ],
        "x-categories": ["Geo-Search"]
      },
      "insideBoundingBox": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          },
          {
            "$ref": "#/components/schemas/insideBoundingBoxArray"
          }
        ]
      },
      "insidePolygon": {
        "type": "array",
        "items": {
          "type": "array",
          "minItems": 6,
          "maxItems": 20000,
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "description": "Coordinates of a polygon in which to search.\n\nPolygons are defined by 3 to 10,000 points. Each point is represented by its latitude and longitude.\nProvide multiple polygons as nested arrays.\nFor more information, see [filtering inside polygons](https://www.algolia.com/doc/guides/managing-results/refine-results/geolocation/#filtering-inside-rectangular-or-polygonal-areas).\nThis parameter is ignored if you also specify `insideBoundingBox`.\n",
        "example": [
          [47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9],
          [40.9234, 2.1185, 38.643, 1.9916, 39.2587, 2.0104]
        ],
        "x-categories": ["Geo-Search"]
      },
      "supportedLanguage": {
        "type": "string",
        "description": "ISO code for a supported language.",
        "enum": [
          "af",
          "ar",
          "az",
          "bg",
          "bn",
          "ca",
          "cs",
          "cy",
          "da",
          "de",
          "el",
          "en",
          "eo",
          "es",
          "et",
          "eu",
          "fa",
          "fi",
          "fo",
          "fr",
          "ga",
          "gl",
          "he",
          "hi",
          "hu",
          "hy",
          "id",
          "is",
          "it",
          "ja",
          "ka",
          "kk",
          "ko",
          "ku",
          "ky",
          "lt",
          "lv",
          "mi",
          "mn",
          "mr",
          "ms",
          "mt",
          "nb",
          "nl",
          "no",
          "ns",
          "pl",
          "ps",
          "pt",
          "pt-br",
          "qu",
          "ro",
          "ru",
          "sk",
          "sq",
          "sv",
          "sw",
          "ta",
          "te",
          "th",
          "tl",
          "tn",
          "tr",
          "tt",
          "uk",
          "ur",
          "uz",
          "zh"
        ]
      },
      "userToken": {
        "type": "string",
        "description": "Unique pseudonymous or anonymous user identifier.\n\nThis helps with analytics and click and conversion events.\nFor more information, see [user token](https://www.algolia.com/doc/guides/sending-events/concepts/usertoken/).\n",
        "example": "test-user-123",
        "x-categories": ["Personalization"]
      },
      "baseSearchParamsWithoutQuery": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "similarQuery": {
            "type": "string",
            "description": "Keywords to be used instead of the search query to conduct a more broader search.\n\nUsing the `similarQuery` parameter changes other settings:\n\n- `queryType` is set to `prefixNone`.\n- `removeStopWords` is set to true.\n- `words` is set as the first ranking criterion.\n- All remaining words are treated as `optionalWords`.\n\nSince the `similarQuery` is supposed to do a broad search, they usually return many results.\nCombine it with `filters` to narrow down the list of results.\n",
            "default": "",
            "example": "comedy drama crime Macy Buscemi",
            "x-categories": ["Search"]
          },
          "filters": {
            "$ref": "#/components/schemas/filters"
          },
          "facetFilters": {
            "$ref": "#/components/schemas/facetFilters"
          },
          "optionalFilters": {
            "$ref": "#/components/schemas/optionalFilters"
          },
          "numericFilters": {
            "$ref": "#/components/schemas/numericFilters"
          },
          "tagFilters": {
            "$ref": "#/components/schemas/tagFilters"
          },
          "sumOrFiltersScores": {
            "type": "boolean",
            "description": "Whether to sum all filter scores.\n\nIf true, all filter scores are summed.\nOtherwise, the maximum filter score is kept.\nFor more information, see [filter scores](https://www.algolia.com/doc/guides/managing-results/refine-results/filtering/in-depth/filter-scoring/#accumulating-scores-with-sumorfiltersscores).\n",
            "default": false,
            "x-categories": ["Filtering"]
          },
          "restrictSearchableAttributes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "example": ["title", "author"],
            "description": "Restricts a search to a subset of your searchable attributes.\nAttribute names are case-sensitive.\n",
            "default": [],
            "x-categories": ["Filtering"]
          },
          "facets": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Facets for which to retrieve facet values that match the search criteria and the number of matching facet values.\n\nTo retrieve all facets, use the wildcard character `*`.\nFor more information, see [facets](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#contextual-facet-values-and-counts).\n",
            "default": [],
            "example": ["*"],
            "x-categories": ["Faceting"]
          },
          "facetingAfterDistinct": {
            "type": "boolean",
            "description": "Whether faceting should be applied after deduplication with `distinct`.\n\nThis leads to accurate facet counts when using faceting in combination with `distinct`.\nIt's usually better to use `afterDistinct` modifiers in the `attributesForFaceting` setting,\nas `facetingAfterDistinct` only computes correct facet counts if all records have the same facet values for the `attributeForDistinct`.\n",
            "default": false,
            "x-categories": ["Faceting"]
          },
          "page": {
            "$ref": "#/components/schemas/page"
          },
          "offset": {
            "type": "integer",
            "description": "Position of the first hit to retrieve.",
            "x-categories": ["Pagination"]
          },
          "length": {
            "type": "integer",
            "description": "Number of hits to retrieve (used in combination with `offset`).",
            "minimum": 0,
            "maximum": 1000,
            "x-categories": ["Pagination"]
          },
          "aroundLatLng": {
            "$ref": "#/components/schemas/aroundLatLng"
          },
          "aroundLatLngViaIP": {
            "$ref": "#/components/schemas/aroundLatLngViaIP"
          },
          "aroundRadius": {
            "$ref": "#/components/schemas/aroundRadius"
          },
          "aroundPrecision": {
            "$ref": "#/components/schemas/aroundPrecision"
          },
          "minimumAroundRadius": {
            "type": "integer",
            "description": "Minimum radius (in meters) for a search around a location when `aroundRadius` isn't set.",
            "minimum": 1,
            "x-categories": ["Geo-Search"]
          },
          "insideBoundingBox": {
            "$ref": "#/components/schemas/insideBoundingBox"
          },
          "insidePolygon": {
            "$ref": "#/components/schemas/insidePolygon"
          },
          "naturalLanguages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/supportedLanguage"
            },
            "description": "ISO language codes that adjust settings that are useful for processing natural language queries (as opposed to keyword searches):\n\n- Sets `removeStopWords` and `ignorePlurals` to the list of provided languages.\n- Sets `removeWordsIfNoResults` to `allOptional`.\n- Adds a `natural_language` attribute to `ruleContexts` and `analyticsTags`.\n",
            "default": [],
            "x-categories": ["Languages"]
          },
          "ruleContexts": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Assigns a rule context to the search query.\n\n[Rule contexts](https://www.algolia.com/doc/guides/managing-results/rules/rules-overview/how-to/customize-search-results-by-platform/#whats-a-context) are strings that you can use to trigger matching rules.\n",
            "default": [],
            "example": ["mobile"],
            "x-categories": ["Rules"]
          },
          "personalizationImpact": {
            "type": "integer",
            "description": "Impact that Personalization should have on this search.\n\nThe higher this value is, the more Personalization determines the ranking compared to other factors.\nFor more information, see [Understanding Personalization impact](https://www.algolia.com/doc/guides/personalization/personalizing-results/in-depth/configuring-personalization/#understanding-personalization-impact).\n",
            "default": 100,
            "minimum": 0,
            "maximum": 100,
            "x-categories": ["Personalization"]
          },
          "userToken": {
            "$ref": "#/components/schemas/userToken"
          },
          "getRankingInfo": {
            "type": "boolean",
            "description": "Whether the search response should include detailed ranking information.",
            "default": false,
            "x-categories": ["Advanced"]
          },
          "synonyms": {
            "type": "boolean",
            "description": "Whether to take into account an index's synonyms for this search.",
            "default": true,
            "x-categories": ["Advanced"]
          },
          "clickAnalytics": {
            "type": "boolean",
            "description": "Whether to include a `queryID` attribute in the response.\n\nThe query ID is a unique identifier for a search query and is required for tracking [click and conversion events](https://www.algolia.com/guides/sending-events/getting-started/).\n",
            "default": false,
            "x-categories": ["Analytics"]
          },
          "analytics": {
            "type": "boolean",
            "description": "Whether this search will be included in Analytics.",
            "default": true,
            "x-categories": ["Analytics"]
          },
          "analyticsTags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags to apply to the query for [segmenting analytics data](https://www.algolia.com/doc/guides/search-analytics/guides/segments/).",
            "default": [],
            "x-categories": ["Analytics"]
          },
          "percentileComputation": {
            "type": "boolean",
            "description": "Whether to include this search when calculating processing-time percentiles.",
            "default": true,
            "x-categories": ["Advanced"]
          },
          "enableABTest": {
            "type": "boolean",
            "description": "Whether to enable A/B testing for this search.",
            "default": true,
            "x-categories": ["Advanced"]
          }
        }
      },
      "baseSearchParams": {
        "allOf": [
          {
            "$ref": "#/components/schemas/searchParamsQuery"
          },
          {
            "$ref": "#/components/schemas/baseSearchParamsWithoutQuery"
          }
        ]
      },
      "hitsPerPage": {
        "type": "integer",
        "description": "Number of hits per page.",
        "default": 20,
        "minimum": 1,
        "maximum": 1000,
        "x-categories": ["Pagination"]
      },
      "typoToleranceEnum": {
        "type": "string",
        "title": "typo tolerance",
        "description": "- `min`. Return matches with the lowest number of typos.\n  For example, if you have matches without typos, only include those.\n  But if there are no matches without typos (with 1 typo), include matches with 1 typo (2 typos).\n- `strict`. Return matches with the two lowest numbers of typos.\n  With `strict`, the Typo ranking criterion is applied first in the `ranking` setting.\n",
        "enum": ["min", "strict"]
      },
      "typoTolerance": {
        "description": "Whether [typo tolerance](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/) is enabled and how it is applied.\n\nIf typo tolerance is true, `min`, or `strict`, [word splitting and concatenation](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/splitting-and-concatenation/) are also active.\n",
        "oneOf": [
          {
            "type": "boolean",
            "default": true,
            "description": "Whether typo tolerance is active. If true, matches with typos are included in the search results and rank after exact matches."
          },
          {
            "$ref": "#/components/schemas/typoToleranceEnum"
          }
        ],
        "x-categories": ["Typos"]
      },
      "booleanString": {
        "type": "string",
        "enum": ["true", "false"]
      },
      "ignorePlurals": {
        "description": "Treat singular, plurals, and other forms of declensions as equivalent.\nYou should only use this feature for the languages used in your index.\n",
        "example": ["ca", "es"],
        "oneOf": [
          {
            "type": "array",
            "description": "ISO code for languages for which this feature should be active.\nThis overrides languages you set with `queryLanguages`.\n",
            "items": {
              "$ref": "#/components/schemas/supportedLanguage"
            }
          },
          {
            "$ref": "#/components/schemas/booleanString"
          },
          {
            "type": "boolean",
            "description": "If true, `ignorePlurals` is active for all languages included in `queryLanguages`, or for all supported languages, if `queryLanguges` is empty.\nIf false, singulars, plurals, and other declensions won't be considered equivalent.\n",
            "default": false
          }
        ],
        "x-categories": ["Languages"]
      },
      "removeStopWords": {
        "description": "Removes stop words from the search query.\n\nStop words are common words like articles, conjunctions, prepositions, or pronouns that have little or no meaning on their own.\nIn English, \"the\", \"a\", or \"and\" are stop words.\n\nYou should only use this feature for the languages used in your index.\n",
        "example": ["ca", "es"],
        "oneOf": [
          {
            "type": "array",
            "description": "ISO code for languages for which stop words should be removed. This overrides languages you set in `queryLanguges`.",
            "items": {
              "$ref": "#/components/schemas/supportedLanguage"
            }
          },
          {
            "type": "boolean",
            "default": false,
            "description": "If true, stop words are removed for all languages you included in `queryLanguages`, or for all supported languages, if `queryLanguages` is empty.\nIf false, stop words are not removed.\n"
          }
        ],
        "x-categories": ["Languages"]
      },
      "queryType": {
        "type": "string",
        "enum": ["prefixLast", "prefixAll", "prefixNone"],
        "description": "Determines if and how query words are interpreted as prefixes.\n\nBy default, only the last query word is treated as a prefix (`prefixLast`).\nTo turn off prefix search, use `prefixNone`.\nAvoid `prefixAll`, which treats all query words as prefixes.\nThis might lead to counterintuitive results and makes your search slower.\n\nFor more information, see [Prefix searching](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/override-search-engine-defaults/in-depth/prefix-searching/).\n",
        "default": "prefixLast",
        "x-categories": ["Query strategy"]
      },
      "removeWordsIfNoResults": {
        "type": "string",
        "enum": ["none", "lastWords", "firstWords", "allOptional"],
        "example": "firstWords",
        "description": "Strategy for removing words from the query when it doesn't return any results.\nThis helps to avoid returning empty search results.\n\n- `none`.\n  No words are removed when a query doesn't return results.\n\n- `lastWords`.\n  Treat the last (then second to last, then third to last) word as optional,\n  until there are results or at most 5 words have been removed.\n\n- `firstWords`.\n  Treat the first (then second, then third) word as optional,\n  until there are results or at most 5 words have been removed.\n\n- `allOptional`.\n  Treat all words as optional.\n\nFor more information, see [Remove words to improve results](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/in-depth/why-use-remove-words-if-no-results/).\n",
        "default": "none",
        "x-categories": ["Query strategy"]
      },
      "mode": {
        "type": "string",
        "enum": ["neuralSearch", "keywordSearch"],
        "description": "Search mode the index will use to query for results.\n\nThis setting only applies to indices, for which Algolia enabled NeuralSearch for you.\n",
        "default": "keywordSearch",
        "x-categories": ["Query strategy"]
      },
      "semanticSearch": {
        "type": "object",
        "description": "Settings for the semantic search part of NeuralSearch.\nOnly used when `mode` is `neuralSearch`.\n",
        "properties": {
          "eventSources": {
            "oneOf": [
              {
                "type": "array",
                "description": "Indices from which to collect click and conversion events.\n\nIf null, the current index and all its replicas are used.\n",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "null"
              }
            ]
          }
        }
      },
      "optionalWordsArray": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "example": ["blue", "iphone case"],
        "description": "List of [optional words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/#creating-a-list-of-optional-words).",
        "default": [],
        "x-categories": ["Query strategy"]
      },
      "optionalWords": {
        "description": "Words that should be considered optional when found in the query.\n\nBy default, records must match all words in the search query to be included in the search results.\nAdding optional words can help to increase the number of search results by running an additional search query that doesn't include the optional words.\nFor example, if the search query is \"action video\" and \"video\" is an optional word,\nthe search engine runs two queries. One for \"action video\" and one for \"action\".\nRecords that match all words are ranked higher.\n\nFor a search query with 4 or more words **and** all its words are optional,\nthe number of matched words required for a record to be included in the search results increases for every 1,000 records:\n\n- If `optionalWords` has less than 10 words, the required number of matched words increases by 1:\n  results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 2 matched words.\n- If `optionalWords` has 10 or more words, the number of required matched words increases by the number of optional words divided by 5 (rounded down).\n  For example, with 18 optional words: results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 4 matched words.\n\nFor more information, see [Optional words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/#creating-a-list-of-optional-words).\n",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          },
          {
            "$ref": "#/components/schemas/optionalWordsArray"
          }
        ]
      },
      "exactOnSingleWordQuery": {
        "type": "string",
        "enum": ["attribute", "none", "word"],
        "description": "Determines how the [Exact ranking criterion](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/override-search-engine-defaults/in-depth/adjust-exact-settings/#turn-off-exact-for-some-attributes) is computed when the search query has only one word.\n\n- `attribute`.\n  The Exact ranking criterion is 1 if the query word and attribute value are the same.\n  For example, a search for \"road\" will match the value \"road\", but not \"road trip\".\n\n- `none`.\n  The Exact ranking criterion is ignored on single-word searches.\n\n- `word`.\n  The Exact ranking criterion is 1 if the query word is found in the attribute value.\n  The query word must have at least 3 characters and must not be a stop word.\n  Only exact matches will be highlighted,\n  partial and prefix matches won't.\n",
        "default": "attribute",
        "x-categories": ["Query strategy"]
      },
      "alternativesAsExact": {
        "type": "string",
        "enum": ["ignorePlurals", "singleWordSynonym", "multiWordsSynonym", "ignoreConjugations"],
        "x-categories": ["Query strategy"]
      },
      "advancedSyntaxFeatures": {
        "type": "string",
        "enum": ["exactPhrase", "excludeWords"],
        "x-categories": ["Query strategy"]
      },
      "distinct": {
        "description": "Determines how many records of a group are included in the search results.\n\nRecords with the same value for the `attributeForDistinct` attribute are considered a group.\nThe `distinct` setting controls how many members of the group are returned.\nThis is useful for [deduplication and grouping](https://www.algolia.com/doc/guides/managing-results/refine-results/grouping/#introducing-algolias-distinct-feature).\n\nThe `distinct` setting is ignored if `attributeForDistinct` is not set.\n",
        "example": 1,
        "oneOf": [
          {
            "type": "boolean",
            "description": "Whether deduplication is turned on. If true, only one member of a group is shown in the search results."
          },
          {
            "type": "integer",
            "description": "Number of members of a group of records to include in the search results.\n\n- Don't use `distinct > 1` for records that might be [promoted by rules](https://www.algolia.com/doc/guides/managing-results/rules/merchandising-and-promoting/how-to/promote-hits/).\n  The number of hits won't be correct and faceting won't work as expected.\n- With `distinct > 1`, the `hitsPerPage` parameter controls the number of returned groups.\n  For example, with `hitsPerPage: 10` and `distinct: 2`, up to 20 records are returned.\n  Likewise, the `nbHits` response attribute contains the number of returned groups.\n",
            "minimum": 0,
            "maximum": 4,
            "default": 0
          }
        ],
        "x-categories": ["Advanced"]
      },
      "order": {
        "description": "Explicit order of facets or facet values.\n\nThis setting lets you always show specific facets or facet values at the top of the list.\n",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "facets": {
        "description": "Order of facet names.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "order": {
            "$ref": "#/components/schemas/order"
          }
        }
      },
      "sortRemainingBy": {
        "description": "Order of facet values that aren't explicitly positioned with the `order` setting.\n\n- `count`.\n  Order remaining facet values by decreasing count.\n  The count is the number of matching records containing this facet value.\n\n- `alpha`.\n  Sort facet values alphabetically.\n\n- `hidden`.\n  Don't show facet values that aren't explicitly positioned.\n",
        "type": "string",
        "enum": ["count", "alpha", "hidden"]
      },
      "hide": {
        "description": "Hide facet values.",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "value": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "order": {
            "$ref": "#/components/schemas/order"
          },
          "sortRemainingBy": {
            "$ref": "#/components/schemas/sortRemainingBy"
          },
          "hide": {
            "$ref": "#/components/schemas/hide"
          }
        }
      },
      "values": {
        "description": "Order of facet values. One object for each facet.",
        "type": "object",
        "additionalProperties": {
          "x-additionalPropertiesName": "facet",
          "$ref": "#/components/schemas/value"
        }
      },
      "facetOrdering": {
        "description": "Order of facet names and facet values in your UI.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "facets": {
            "$ref": "#/components/schemas/facets"
          },
          "values": {
            "$ref": "#/components/schemas/values"
          }
        }
      },
      "redirectURL": {
        "description": "The redirect rule container.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "bannerImageUrl": {
        "description": "URL for an image to show inside a banner.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "bannerImage": {
        "description": "Image to show inside a banner.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "urls": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/bannerImageUrl"
            }
          },
          "title": {
            "type": "string"
          }
        }
      },
      "bannerLink": {
        "description": "Link for a banner defined in the Merchandising Studio.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "url": {
            "type": "string"
          }
        }
      },
      "banner": {
        "description": "Banner with image and link to redirect users.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "image": {
            "$ref": "#/components/schemas/bannerImage"
          },
          "link": {
            "$ref": "#/components/schemas/bannerLink"
          }
        }
      },
      "banners": {
        "description": "Banners defined in the Merchandising Studio for a given search.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/banner"
        }
      },
      "widgets": {
        "description": "Widgets returned from any rules that are applied to the current search.",
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "banners": {
            "$ref": "#/components/schemas/banners"
          }
        }
      },